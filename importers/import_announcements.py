# importers/import_announcements.py
from __future__ import annotations
import json
from pathlib import Path
from typing import Any, Dict, Optional, Protocol
import requests
from logging_setup import get_logger

__all__ = ["import_announcements"]

class CanvasLike(Protocol):
    session: requests.Session
    api_root: str
    def post(self, endpoint: str, **kwargs) -> requests.Response: ...

def _read_json(path: Path) -> Dict[str, Any]:
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)

def _read_text_if_exists(path: Path) -> Optional[str]:
    return path.read_text(encoding="utf-8") if path.exists() else None

def _find_meta_file(dirpath: Path) -> Optional[Path]:
    # Try common names generated by exporters
    for name in ("announcement_metadata.json", "discussion_metadata.json", "topic_metadata.json", "metadata.json"):
        p = dirpath / name
        if p.exists():
            return p
    return None

def _find_html_file(dirpath: Path, meta: Dict[str, Any]) -> Optional[Path]:
    # 1) honor explicit html_path
    if isinstance(meta.get("html_path"), str):
        p = dirpath / meta["html_path"]
        if p.exists():
            return p
    # 2) common fallbacks
    for name in ("body.html", "message.html", "index.html", "description.html"):
        p = dirpath / name
        if p.exists():
            return p
    return None

def import_announcements(
    *,
    target_course_id: int,
    export_root: Path,
    canvas: CanvasLike,
    id_map: dict[str, dict],
) -> dict[str, int]:
    """
    Import announcements exported as folders under export_root/announcements/<slug-or-id>/.

    Creates discussion topics with is_announcement=True:
      POST /api/v1/courses/:id/discussion_topics
        payload: { "title": ..., "message": ..., "is_announcement": true, ... }

    Records id_map["announcements"][old_id] = new_id when both available.
    """
    log = get_logger(course_id=target_course_id, artifact="announcements")
    counters = {"imported": 0, "skipped": 0, "failed": 0, "total": 0}

    ann_dir = export_root / "announcements"
    if not ann_dir.exists():
        log.info("nothing-to-import at %s", ann_dir)
        return counters

    id_map.setdefault("announcements", {})

    for topic_dir in sorted(p for p in ann_dir.iterdir() if p.is_dir()):
        meta_path = _find_meta_file(topic_dir)
        if not meta_path:
            counters["skipped"] += 1
            log.warning("missing_metadata dir=%s", topic_dir)
            continue

        try:
            meta = _read_json(meta_path)
        except Exception as e:
            counters["failed"] += 1
            log.exception("failed to read metadata %s: %s", meta_path, e)
            continue

        counters["total"] += 1

        title = str(meta.get("title") or "").strip()
        if not title:
            counters["skipped"] += 1
            log.warning("skipping %s (missing title)", meta_path)
            continue

        html_path = _find_html_file(topic_dir, meta)
        if not html_path:
            counters["skipped"] += 1
            log.warning("missing_html title=%s dir=%s", title, topic_dir)
            continue

        message_html = _read_text_if_exists(html_path) or ""

        payload: Dict[str, Any] = {
            "title": title,
            "message": message_html,
            "is_announcement": True,
        }
        # Optional passthroughs if present (safe, Canvas will ignore unknowns)
        for key in ("delayed_post_at", "lock_at", "pinned"):
            if key in meta and meta[key] is not None:
                payload[key] = meta[key]

        try:
            log.debug("create announcement title=%r bytes=%d dir=%s",
                      title, len(message_html.encode("utf-8")), topic_dir)
            resp = canvas.post(f"/api/v1/courses/{target_course_id}/discussion_topics", json=payload)
            data = {}
            try:
                data = resp.json()
            except ValueError:
                pass
        except Exception as e:
            counters["failed"] += 1
            log.exception("failed-create title=%s: %s", title, e)
            continue

        new_id = data.get("id")
        old_id = meta.get("id")
        if isinstance(old_id, int) and isinstance(new_id, int):
            id_map["announcements"][old_id] = new_id

        counters["imported"] += 1

    log.info(
        "Announcements import complete. imported=%d skipped=%d failed=%d total=%d",
        counters["imported"], counters["skipped"], counters["failed"], counters["total"],
    )
    return counters
